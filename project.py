# -*- coding: utf-8 -*-
"""Final_Year_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kl0vzU6QjuLUeAGkq-HCq0zUxo1NTgZU
"""

data = pd.read_csv(r"/content/Train.txt")
print(data.head())
print(data.info())

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.preprocessing import OneHotEncoder

"""# New Section"""

data.dropna(inplace=True)
X = data.iloc[:, :-1]
y = data.iloc[:, -1]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
print(X_train.head())

model = LogisticRegression()
categorical_cols = [col for col in X.columns if X[col].dtype == 'object']

# One-hot encode the categorical variables
encoder = OneHotEncoder(handle_unknown='ignore')
X_encoded = encoder.fit_transform(X[categorical_cols])

# Concatenate the encoded features with the numerical features
X_final = np.concatenate((X.select_dtypes(include=['float64']), X_encoded.toarray()), axis=1)

# Split the data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X_final, y, test_size=0.2, random_state=0)

# Fit the model on the train set
model = LogisticRegression()
model.fit(X_train, y_train)
# model.fit(X_train, y_train)

y_pred = model.predict(X_test)
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

# new_data = np.array([[20, 40, 50, 5]])
new_data = pd.read_csv(r"/content/Test.txt")
# prediction = model.predict(new_data)
# Assuming 'new_data' is your new data that you want to make predictions on

categorical_cols = [col for col in X.columns if X[col].dtype == 'object']

# One-hot encode the categorical variables
encoder = OneHotEncoder(handle_unknown='ignore')
X_newencoded = encoder.fit_transform(X[categorical_cols])
X_newfinal = np.concatenate((X.select_dtypes(include=['float64']), X_encoded.toarray()), axis=1)
# new_data_encoded = encoder.fit_transform(new_data[X_newfinal])
# new_data_final = np.concatenate((new_data.select_dtypes(include=['float64']), new_data_encoded.toarray()), axis=1)

# Make predictions on the new data
# prediction = model.predict(new_data_final)
# print(prediction)

# print(prediction)
